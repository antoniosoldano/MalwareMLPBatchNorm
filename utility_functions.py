import torch

def compute_accuracy(net, data_loader):
    net.eval()
    correct_pred, num_examples = 0, 0
    with torch.no_grad():
        for features, targets in data_loader:

            features = features.to(torch.float32)
            features = features.to(device)
            num_examples += targets.size(0)
            targets = torch.reshape(targets.to(torch.float32), [len(targets), -1])
            targets = targets.to(device)
            logits, probas = net(features)
            _, predicted_labels = torch.max(probas, 1)
            # num_examples += targets.size(0)
            correct_pred += (predicted_labels == targets).sum()

            # Accuracy
            #print("Testing Accuracy: {0:.4f}".format(metrics.accuracy_score(predicted_labels.cpu(), targets.cpu())))
            print(correct_pred.float())

        return correct_pred.float() / num_examples * 100

def binary_acc(y_pred, y_test):
    y_pred_tag = torch.round(torch.sigmoid(y_pred))

    correct_results_sum = (y_pred_tag == y_test).sum().float()
    acc = correct_results_sum / y_test.shape[0]
    acc = torch.round(acc * 100)

    return acc