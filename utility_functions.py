import torch

# def compute_accuracy(net, data_loader):
#     net.eval()
#     correct_pred, num_examples = 0, 0
#     with torch.no_grad():
#         for features, targets in iter(data_loader):
#
#             features = features.to(torch.float32)
#             features = features.to(device)
#             num_examples += targets.size(0)
#             targets = torch.reshape(targets.to(torch.float32), [len(targets), -1])
#             targets = targets.to(device)
#             logits, probas = net(features)
#             # num_examples += targets.size(0)
#             correct_pred += (logits == targets).sum()
#
#             # Accuracy
#             #print("Testing Accuracy: {0:.4f}".format(metrics.accuracy_score(predicted_labels.cpu(), targets.cpu())))
#             print(correct_pred.float())
#
#         return correct_pred.float() / num_examples * 100

def compute_accuracy(net, data_loader):

    device = torch.device("cuda:0" if torch.cuda.is_available() else "cpu")
    correct_pred, num_examples = 0, 0
    with torch.no_grad():
        for features, targets  in iter(data_loader):

            features = features.to(device).float()
            targets = targets.to(device).long()

            num_examples += targets.size(0)

            logits, probas = net(features)
            _, predicted_labels = torch.max(probas, 1)

            correct_pred += (predicted_labels == targets).sum()
        return correct_pred.float() / num_examples * 100

def binary_acc(y_pred, y_test):
    y_pred_tag = torch.round(torch.sigmoid(y_pred))

    correct_results_sum = (y_pred_tag == y_test).sum().float()
    acc = correct_results_sum / y_test.shape[0]
    acc = torch.round(acc * 100)

    return acc